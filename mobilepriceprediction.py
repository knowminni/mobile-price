# -*- coding: utf-8 -*-
"""MobilePricePrediction.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qGy94bFT0_HBjmA9ODUEElzjyinotDi6

## ***Import Dependencies***
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import pandas as pd

import seaborn as sns
import matplotlib.pyplot as plt
# %matplotlib inline

import warnings
warnings.filterwarnings('ignore')

"""### **Classification Models to be considered:**
    1. Logistic Regression
    2. Logistic Regression with Cross Validator
    3. Stochastic Gradient Descent Classifier
    4. Gaussian Naive Bayes
    5. K Nearest Neighbors
    6. Random Forest Classifier
    7. Support Vector Machine
"""

from google.colab import files
import io

from sklearn.linear_model import LogisticRegression, LogisticRegressionCV, SGDClassifier
from sklearn.naive_bayes import GaussianNB
from sklearn.neighbors import KNeighborsClassifier
from sklearn.ensemble import RandomForestClassifier
from sklearn.svm import SVC

from sklearn.model_selection import GridSearchCV, train_test_split, RandomizedSearchCV
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score, plot_confusion_matrix
from sklearn.metrics import accuracy_score, confusion_matrix, classification_report
from sklearn.externals import joblib

"""## ***Importing Data Source***"""

uploaded = files.upload()

data = pd.read_csv(io.BytesIO(uploaded['train.csv']))
data

data.head()

data.info()

data.describe()

# Renaming column names
names = ['Battery', 'Bluetooth', 'ClockSpeed', 'DualSim', 'FrontCam',
         'FourG', 'Internal', 'Depth', 'Weight', 'NumCores',
         'PrimaryCam', 'PxHeight', 'PxWidth', 'Ram', 'ScHeight', 'ScWidth',
         'TalkTime', 'ThreeG', 'Touch', 'WiFi', 'PriceRange']

data.columns = names
data

"""#### ***Categorical Data and Numerical Data***"""

num_col = data.select_dtypes(include = np.number).columns
categ_col = data.select_dtypes(exclude = np.number).columns

print("\n Numerical Columns: ", num_col)
print("\n Categorical Columns: ", categ_col)

# Checking for NA values

print(data.isna().sum())
print(data.shape)

"""## ***Data Visualization and Exploratory Data Analysis***

### ***1. Checking Target Class Distribution***
"""

sns.countplot(y = data['PriceRange'], data = data)
plt.xlabel('Count of each Target class')
plt.ylabel('Target Classes')
plt.show()

"""Conclusion : Target Variable 'Price Range' is equally distributed.

### ***2. Checking Feature Distribution***
"""

data.hist(figsize = (20, 12), bins = 15)
plt.title('Feature Distribution')
plt.show()

"""### ***3. Check Collinearity of Data***"""

plt.figure(figsize = (30, 20), dpi = 80)
p = sns.heatmap(data[num_col].corr(), annot = True, center = 0, cmap = 'RdYlGn')

"""### ***4. Inter Class Collinearity***"""

fig, ax = plt.subplots(nrows = 7, ncols = 3, figsize = (20,25))
plt.title('Individual Features by Class')
row = 0
col = 0
for i in range(len(data.columns)):
    if col > 2:
        row += 1
        col = 0
    axes = ax[row, col]
    sns.boxplot(x = 'PriceRange', y = data.columns[i], data = data, ax = axes)
    col += 1

plt.tight_layout()
plt.show()

data.head()

"""## ***Splitting Data in Train, Test and Validation***"""

X = data.drop(['PriceRange'], axis = 1)
y = data['PriceRange']

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.20, random_state = np.random)

"""### ***Model Evaluation and Model Metrics Functions***"""

def evaluateModel(actual, prediction):
    print('\n\n\nConfusion Matrix:\n', confusion_matrix(actual, prediction))
    print('\n\nAccuracy Score:  {:.2f}%'.format(accuracy_score(actual, prediction)*100))
    print('\n\nClassification Report:\n', classification_report(actual, prediction))

def mean_absolute_percentage_error(actual, prediction):
    y_true, y_pred = np.array(actual), np.array(prediction)
    return np.mean(np.abs((actual - prediction)/ actual)) * 100

def modelMetrics(actual, prediction):
    print('R2 Score: ',r2_score(actual, prediction))
    print('MAE Score: ', mean_absolute_error(actual, prediction))
    print('MSE Score: ', mean_squared_error(actual, prediction))
    print('MAPE Score: ', mean_absolute_percentage_error(actual, prediction))

"""## ***Model Building - Support Vector Machine Classifier***"""

sup = SVC()
sup.fit(X_train, y_train)
print('Support Vector Machine Model: \n', sup)
suppred = sup.predict(X_test)

modelMetrics(y_test, suppred)

evaluateModel(y_test, suppred)

"""## ***Visualizing Confusion Matrices***"""

#Defining Labels
k = ['Range 0', 'Range 1', 'Range 2', 'Range 3']

"""### **Support Vector Machine Classifier: 96.25%**"""

fig, ax = plt.subplots(figsize=(6,6))
plot_confusion_matrix(sup, X_test, y_test, cmap = 'hot', display_labels = k, values_format='.0f', ax =ax )

"""## **Predicting Classes for Test Data**"""

data2 = files.upload()

testDf = pd.read_csv(io.BytesIO(data2['test.csv']))

testDf

data.head(2)

testDf.head(2)

print('Shape of Original Data: ',data.shape)
print('Shape of Test Data: ',testDf.shape)

testDf.drop('id', inplace = True, axis = 1)

testDf.columns = names[:-1]

predictions = sup.predict(testDf)

testDf['PriceRange'] = predictions
testDf

testDf.to_csv('Test_Data_Predicted.csv')

"""## ***Export Model***"""

joblib.dump(sup,'SVM_Model.pkl')
print('Model Generated')
